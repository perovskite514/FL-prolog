嶋村光太郎 05-211013

問1
 
　仮定として以下のものが与えられている。
1. eq(a, b)
2. eq(c, b)
3. for all X, Y, Z. eq(X, Y) ∧ eq(Y, Z) -> eq(X, Z)
4. for all X, Y. eq(Y, X) -> eq(X, Y)

　まず、仮定2から eq(c, b)
　さらに、仮定4の X = b, Y = cの場合から eq(b, c)
　また、仮定1より eq(a, b) ∧ eq(b, c)
　最後に、仮定3の X = a, Y = b, Z = cの場合から eq(a, c)
　従って、eq(a, c)

　Prolog処理系で問い合わせてみると、無限ループになった。eq(a, c)の
問い合わせの様子について考察する。
　まず、?- eq(a, c)はスライドの三段目のruleから
    ?- eq(a, Y), eq(Y, c).
となる。続いて、eq(a, Y)に対して代入が行われる。この時、まず、
eq(a, b)から Y := bの代入が行われる。続いてeq(b, c)に対して、三段目の
ruleが用いられて
    ?- eq(b, Y), eq(Y, c)となる。
　このように、三段目のruleが適用されることが繰り返されて無限ループになっていると考えられる。

　対策としては、prolog処理系を幅優先探索で探索するようにすればよいと考えられる。何故なら、そうすることで
ルールの優先順位に縛られないルールの適用が可能になり、この例だと、ルールをいつでも自由に適用することで、
eq(a, c)の問い合わせがtrueになる。
　具体的にはeq(a, c) -> eq(c, a)　-> eq(c, Y) , eq(Y, a) -> eq(c, b) , eq(b, a) -> eq(b, a) -> eq(a, b)といった
流れでルールが適用されてtrueになる。

問2

　有限の項のみを許すという仮定の元では、X≠f(X)となるため、testの導出は不能であり、よって
論理的解釈はfalseになる。
　prolog処理系に問い合わせるとtrueになる。これは、prolog処理系では出現検査を行っていないため、
X=f(X)が認められるからである。実際に?- q(X, X).を問い合わせると、X = f(X)が返ってくる。

問3

　論理的な解釈では、変数を持つ命題の否定は計算をせずに別のゴールの導出を行うため、
まず、q(X)の導出が行われて、ここで変数Xが具体化されてから￢p(X)が導出されるため、
期待される結果はX = bになる。

　prolog処理系に問い合わせるとfalseになる。これは、prologの処理系では変数がある命題にも
失敗による否定を用いようとするためである。prologではp(a)から?- \+p(X)をfalseとするため、
問い合わせた結果もfalseになる。

 論理的解釈とprolog処理系の応答を一致させるには、prolog処理系のゴールを解決する順序
が左から右であることを踏まえて、今回のケースだと?- q(X), \+p(X)と問い合わせを書き換えればよい。
こうすることで、変数が具体化された状態で\+p(X)の解決が行われる。

発展1

　仮定として以下のものが与えられている。
1. p(a) -> r(a)
2. ¬p(a) -> r(a)
3. for all X. p(f(X)) -> p(X) 
　定義されている命題は真偽が唯一つに定まり、また、定義されていない命題は閉世界仮説より偽であるため、
排中律を認めることが出来て、p(a) ∨ ¬p(a)が仮定として認められる。
これを仮定4とする。

　ここで、仮定1より、p(a) -> r(a)
　ここで、仮定2より、¬p(a) -> r(a)
　よって、p(a) ∨ ¬p(a) -> r(a)　
　ここで、仮定4より、p(a) ∨ ¬p(a) 
　従って、r(a)

　ここで、?- r(a).をprolog処理系に問い合わせるとOut of global stackとなる。
これは、prolog処理系では上のルールが優先されるため、r(a) :- p(a)が適用されて、
続いてp(X) :- p(f(X))が適用され続けることによって無限ループに陥るからである。